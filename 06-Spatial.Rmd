# Statistiques spatiales {#spatial}

```{r setup, results='hide', warning=FALSE, include=FALSE}
SciViews::R
```

Les statistiques spatiales, également en connexion avec les systèmes d'information géographique (SIG), représentent un très large sujet. Il intéresse potentiellement tout biologiste qui travaille avec des données spatialisées, qu'elles soient à 2, 3 ou 4 dimensions (écologie, environnement, épidémiologie, dynamique des populations, biodiversité, etc.) Il est impossible de l'aborder de manière exhaustive en un seul module. Il s'agit donc ici d'une première approche qui vise à vous montrer que R aussi peut être utile dans ce domaine. Voyez les liens dans les sections "pour en savoir plus", si vous voulez approfondir ce sujet.

##### Objectifs {-}

- Être capable de construire une carte dans R et d'y ajouter des éléments tels des points, des formes, des colorations spécifiques en fonction d'une variable quantitative ou qualitative

- Comprendre les principaux systèmes de coordonnées

- Être capable de calculer des distance et des aires à partir de données spatialisées

- S'initier à l'interpolation spatiale

##### Prérequis {-}

Ce module fait suite aux modules 4 et 5 consacrés aux séries spatio-temporelles. Diverses notions, comme l'autocorrélation, sont également utiles ici. Assurez-vous d'avoir bien compris la matière des modules 4 et 5 avant d'aborder celui-ci. De plus, la section concernant la cartographie fait appel aux graphiques dans R qui constituent les modules 2 à 4 du cours SDD I.

## Réalisation de cartes

Les cartes sont des outils de présentation très utiles dès lors que les données à représenter sont liées à des coordonnées géographiques. Des logiciels spécialisés dans le traitement de ce type de données et dans la réalisation de cartes existent\ : ce sont les logiciels de SIG (Systèmes d'Information Géographique, ou GIS en anglais). Le plus connu est sans aucun doute [ArcGIS](https://www.esri.com/en-us/arcgis/about-arcgis/overview). Des alternatives Open source existent comme [GRASS](https://grass.osgeo.org) ou [QGIS](https://www.qgis.org/en/site/). Ces outils sont assez complexes et requièrent une formation minimale non négligeable pour pouvoir les utiliser.

Une alternative simple est de réaliser des cartes directement dans R. L'avantage de réaliser une carte avec R est de pouvoir associer des représentations graphiques avec les outils d'analyses statistiques. Il s'agit, à la fois, d'une option viable pour l'utilisateur occasionnel, et un choix qui se justifie dans des contextes où la carte n'est pas le seul élément important du projet (carte à intégrer dans un document R Markdown, ou à inclure dans un contenu dynamique tel un "dashboard" écrit en R et [Shiny](https://shiny.rstudio.com), par exemple). A titre d'exemple, vous pouvez explorer ces deux applications\ : [COVID-16 tracker](https://vac-lshtm.shinyapps.io/ncov_tracker/?_ga=2.222275100.56067852.1608025707-917889845.1607892304) et [ZIP explorer](https://shiny.rstudio.com/gallery/superzip-example.html) qui vous montrent que la cartographie et la gestion de données spatialisées dans R est parfaitement réalisable avec un résultat très professionnel.

Il existe de très nombreux packages dans R pour réaliser des cartes, cependant, {sf} est un package relativement récent (2017) dont l'objectif est de regrouper et optimiser les fonctionnalités qui sont proposées dans divers packages plus anciens tels que {sp}, {rgdal} et {rgeos}. Nous utiliserons donc ici principalement {sf}, combiné aux fonctionnalités de cartographie de {ggplot2} par l'intermédiaire de notre fonction habituelle de création de graphiques `chart()`.

D'autres packages seront nécessaires, notamment ceux qui contiennent des fonds de cartes comme {tmap}. Dans R, il existe de nombreux objets différents pour représenter des données spatialisées. {sf} propose donc toute une série de fonction pour les convertir en objets **sf** que nous privilégierons ici. Ainsi, pour avoir une carte du monde, nous pourrons fire ceci\ :

```{r}
library(sf)
# Fond de carte mondial de {tmap} converti en objet sf
world <- st_as_sf(read("World", package = "tmap"))
class(world)
```


Un objet **sf** est tout simplement un tableau de données classiques de type cas par variables que vous avez l'habitude de manipuler, mais qui contient une colonne décrivant la zone géographique concernée. Dans notre objet world, la colonne `geometry` décrit des polygones grâce au type **sfc_MULTIPOLYGON**. Le type de la variable `geometry` varie en fonction des coordonnées géographiques avec par exemple sfc_point, sfc_linestring ou encore sfc_polygon.


```{r}
world
```

##### A vous de jouer ! {-}

`r h5p(57, height = 270, toc = "Objet sf")`

Nous voyons qu'outre les frontières des pays dans la variable `geometry`, {tmap} nous renvoie aussi une série d'autres données utiles, comme la superficie de chaque pays dans `area` (utile pour rapporter des observations par unité de surface, par exemple). De votre côté, vous pourrez donc combiner également vos données avec leur localisation dans un tableau **sf**.

De plus, les objets **sf** sont compatibles avec les fonctions de manipulation de tableaux de données qui sont familières pour vous comme `select()`, `filter()`, `*_join()`,...

```{r}
# Tableau réduit en éliminant des colonnes superflues
world %>.%
  select(., name, area, pop_est, economy, geometry) -> world2

head(world2)
```

Pour réaliser une carte, nous utiliserons `chart()` comme d'habitude, mais en ne lui indiquant aucune "esthétique" à utiliser à l'aide de formule. Les "aesthetics" dans {ggplot2} sont les variables utilisées pour construire le graphique. Ensuite, nous utiliserons `geom_sf()` qui sait où trouver les polygones à utiliser pour créer le fond de carte.

Malheureusement, la version de `chart()` dans la SciViews Box 2020 ne supporte pas encore les objets **sf**. Le code suivant remédie à cette lacune (ajoutez ce code dans chacun de vos documents avant d'utiliser `chart()` pour faire des cartes). Il sera naturellement intégré dans la prochaine version du package {chart} et donc, dans la prochaine SciViews Box.

```{r}
SciViews::R
chart.sf <- function(data, specif = aes(), formula = NULL, mapping = aes(), type = NULL, theme = theme_svmap, env = parent.frame()) {
  if (!missing(specif))
    if (inherits(specif, "formula")) {
      formula <- specif
    } else if (inherits(specif, "uneval")) {
      mapping <- specif
    } else rlang::abort("'specif' must be either a formula or aes()/f_aes()")
  if (!is.null(formula)) {
    args <- chart:::as_list(match.call())[-1]
    args$data <- NULL
    args$specif <- NULL
    args$formula <- NULL
    args$mapping <- NULL
    args$type <- NULL
    args$auto.labs <- NULL
    args$env <- NULL
    mapping <- chart:::.rename_aes(chart:::.f_to_aes(formula, args, with.facets = TRUE))
    # Special case ~0
    if (is.numeric(mapping$x) && mapping$x == 0)
      mapping$x <- NULL
  }
  facets <- mapping$facets
  mapping$facets <- NULL
  p <- ggplot(data = data, mapping = mapping, environment = env) +
    theme()
  if (!is_null(facets)) {
    if (is_null(rlang::f_lhs(facets))) {
      p <- p + facet_wrap(facets)
    } else {
      p <- p + facet_grid(facets)
    }
  }
  if (inherits(p, "ggplot")) 
    class(p) <- unique(c("Chart", class(p)))
  p
}
```

Ensuite, réaliser une carte du monde est enfantin\ :

```{r}
chart(data = world) +
  geom_sf()
```

Si nous ne voulons pas le fond grisé, ni les méridens, nous pouvons utiliser le thème `ggsn::blank()`. Nous verrons plus loin que le package {ggsn} permet d'autres annotations pour orienter et indiquer l'échelle sur la carte ensuite.

```{r}
chart(data = world) +
  geom_sf() +
  ggsn::blank()
```

##### A vous de jouer ! {-}

`r h5p(58, height = 270, toc = "But du package ggsn")`

Là où cela devient intéressant, c'est que nous avons la possibilité d'utiliser les autres variables contenues dans le tableau **sf** pour annoter la carte. Par exemple, nous pouvons remplir les polygones (`%fill=%`) représentant les différents pays à l'aide d'une couleur en fonction de la variable `economy`. Une petite astuce toutefois\ : une formule doit obligatoirement contenir une variable `x` après le tilde. Or ici, nous ne voulons fournir que `fill`, mais ni `x`, ni `y` dans la formule. Pour cela, nous indiquons `~ 0` qui sera compris par `chart()` comme aucun `x` et aucun `y`. Ensuite, nous pourrons rajouter toutes les autres esthétiques comprises par {ggplot2} à la suite dans la formule sous la forme `%aes=% variable`, donc ici, `%fill=% economy`.


```{r}
chart(data = world, ~0 %fill=% economy) +
  geom_sf()
```

##### A vous de jouer ! {-}

`r h5p(59, height = 270, toc = "Syntaxe de chart")`

Pour présenter de l'information sur une carte, nous aurons donc besoin d'une ou plusieurs variables qualitatives ou quantitatives associées à des coordonnées spatiales. Les données et les coordonnées spatiales seront, en pratique, souvent dans deux tableaux différents. Vous aurez donc à les combiner en un tableau unique **sf** avant de pouvoir réaliser la carte voulue.

Dans la suite de cette partie, nous verrons successivement comment ajouter et échelle et orienter une carte, comment importer des données géographiques et des fonds de cartes, et ce que sont les CRS ou systèmes de coordonnées géodésiques. Ces éléments sont indispensables pour tracer sa carte correctement. Dans la partie suivante, nous nous attaquerons à la partie plus intéressante qui concerne l'annotation de vos cartes.

### Échelle et orientation

Toute carte qui se respecte contient deux éléments importants\ : une orientation de la carte via l'indication du nord géographique, et une échelle qui permet d'avoir une idée des distances. Nous allons ajouter ces éléments à notre carte du monde grâce au package [{ggsn}](http://oswaldosantos.github.io/ggsn/).

La fonction `ggsn::north()` oriente le nord sur la carte, tandis que `ggsn::scalebar()` ajoute une barre d'échelle. Ces deux fonctions prennent comme premier argument, le jeu de données utilisé. Pour `ggsn::scalebar()` il faut aussi indiquer pas mal de choses pour paramétrer l'échelle, en particulier, la distance et l'unité. Cela demande quelques essais et erreurs avant d'avoir une barre d'échelle correcte. Par exemple pour l'Italie, cela donne\ :

```{r}
world %>.%
  filter(., name == "Italy") %>.%
  chart(data = .) +
    geom_sf() +
    ggsn::north(., location = "topright", symbol = 3) +
    ggsn::scalebar(., dist = 150, dist_unit = "km", location = "bottomleft",
      transform = FALSE, height = 0.015,
      st.dist = 0.02, st.size = 3, border.size = 0.5)
```

### Importation de "shapefiles"

Les fonds de cartes sont principalement stockés dans des fichiers au format [**shapefile** de ESRI](https://doc.arcgis.com/fr/arcgis-online/reference/shapefiles.htm). Comme nous l'avons déjà vu, certains packages R comme {tmap} en proposent déjà directement intégrés à R mais souvent, vous devrez les importer vous-même. Votre première tâche sera donc de trouver des données spatiales qui correspondent à la zone géographique étudiée. Vous pouvez les trouver dans des sites spécialisés comme\ : 

- [Géoportail des institutions fédérales belges](https://www.geo.be/home?l=fr) pour la Belgique
- [GEODATA sur eurostat](https://ec.europa.eu/eurostat/web/gisco/geodata) pour l'Europe

##### A vous de jouer ! {-}

`r h5p(60, height = 270, toc = "Fonds de cartes")`

La fonction `st_read()` permet de lire ces données dans R. Attention, les fichiers au format **shapefile** (dont l'extension est `.shp`) sont associé à trois autres fichiers indispensables à la réalisation de votre carte (avec les extensions `.shx`, `.dbf` et `.prj`). Si, par exemple, vous avez placé ces fichiers dans le sous-répertoire `data` avec le nom `europe`, vous ferez\ :

```{r, eval=FALSE}
europe_map <- st_read("data/europe.shp")
```

```{block2, type = 'note'}
Les fichiers au format **shapefile** sont souvent assez volumineux. La précision de la carte aura une très grande importance sur la taille du fichier. Le tableau ci-dessous met en avant la différence de la taille du fichier en fonction de l'échelle de la carte des pays d'Europe <https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units/countries#countries20> 

Cartes de l'Europe au format **shapefile** en fonction de l'échelle de la carte.

|Echelle | Taille du fichier  |
|--------------|--------------|
| 1:1 million  |    168 Mo    |
| 1:3 million  |   42.3 Mo    |
| 1:10 million |    9.6 Mo    |
| 1:20 million |    4.5 Mo    |
| 1:60 million |   0.57 Mo    |

```

##### A vous de jouer ! {-}

`r h5p(61, height = 270, toc = "Echelle des cartes")`

### Systèmes de coordonnées

La terre n'est pas plate, vous le savez (elle n'est pas tout à fait ronde non plus). Son axe de rotation n'est pas fixe. La gravité y est variable. Nous devons donc projeter des objets tridimensionnels en deux dimensions sur notre carte. Une projection va inévitablement plus ou moins déformer notre visualisation en deux dimensions. Il existe plusieurs projections différentes avec des caractéristiques particulières (respect des distances, des volumes, etc.). Vous devrez sélectionner et utiliser celle qui convient le mieux à votre carte. 

La fonction `st_crs()` vous renvoie toutes les informations lié au système géodésique (*Coordinate Reference System, CRS*) utilisé. Ces notions sont très complexes et sortent du cadre de ce cours. Nous pouvons néanmoins citer le WGS84 qui est le système utilisé par le GPS que nous connaissons tous. Chaque pays a un système qui lui est propre et qui a évolué au cours du temps. Le tout rend le traitement des données spatiales encore plus complexe.

Afin de clarifier et unifier ces différents systèmes de référence, un code est attribué à chacun d'eux dans le standard **[EPSG](https://epsg.io)**. Par exemple, le EPSG:4326 correspond au système WGS84 cité plus haut et utilisé par les GPS. Lors de la combinaison de différentes données spatiales, il sera indispensable de vous assurer que ces données sont compatible et obtenue via le même CRS. La Belgique a employé et continue d'employer plusieurs systèmes différent. Le site [epsg.io](http://epsg.io/?q=belgium) en recense huit\ ! Nous vous conseillons vivement de lire maintenant [comprendre les CRS](https://medium.com/cr%C3%A9ation-dune-app-cartographique-avec-firebase-vue/comprendre-les-coordinates-reference-system-crs-b67a88bce63c) pour tout savoir ou presque sur ces systèmes de coordonnées. 

La carte du monde présenté précédemment suit les conventions de la norme EPSG:4326, alias WGS84.

```{r}
st_crs(world)
```

##### A vous de jouer ! {-}

`r h5p(62, height = 270, toc = "Standard EPSG")`

Intéressons-nous maintenant à l'Afrique australe définie par l'ONU comme constituée des pays suivants\ : Afrique du Sud, Namibie, Botswana, Lesotho et Swaziland.

```{r}
southern_africa <- c("Botswana", "Lesotho", "Namibia", "South Africa", "Swaziland")
```

Nous commençons avec une carte du continent africain tout entier\ :

```{r}
world %>.%
  filter(., continent == "Africa") %>.%
  mutate(., austral = name %in%  southern_africa) -> africa

chart(data = africa, ~0 %fill=% austral) +
  geom_sf()
```

La fonction qui permet de transformer les coordonnées géographiques d'un CRS à un autre est tout simplement `st_transform()`. Nous pouvons simplement comparer les mêmes données spatiales avec deux CRS différents. Ce premier graphique utile la convention EPSG:4326 présenté précédemment.

Ce second graphique utilise le CRS EPSG:22235 qui est centré sur l'Afrique du Sud. Nous n'avons aucunement changé les données. Il s'agit simplement de deux représentations différentes des *mêmes* données géographiques.

```{r}
africa %>.%
  st_transform(., 22235) -> africa_sa

chart(data = africa_sa, ~0 %fill=% austral) +
  geom_sf()
```

La carte dont le système géodésique est adapté à la zones étudiée est plus intéressante, visuellement parlant et aussi parce que les distances et les surfaces dans cette zone sont mieux respectées. En effet, cette zone est moins déformée par la projection en deux dimensions.

## Annotation de cartes

L'annotation de carte consiste à ajouter des couches d'information par dessus le fond de carte. C'est bien évidemment ces fonctions d'annotation qui font tout l'intérêt des SIG, ainsi que des cartes générées dans R.

### Labels et textes

Afin qu'une carte soit plus compréhensible, nous ajoutons des informations sous la forme de labels avec `geom_sf_label()` ou de texte avec `geom_sf_text()`. Il faut être particulièrement attentif à la taille du texte (contrôlable avec `size=`). Concentrons-nous maintenant sur l'Afrique australe.

```{r}
africa_sa %>.%
  filter(., name %in% southern_africa) -> s_africa_sa
```

Pour les Européens, par exemple, cette zone du monde est difficilement reconnaissable telle quelle. L'ajout du nom des pays est donc une information utile pour la situer.

```{r}
chart(data = s_africa_sa) +
  geom_sf() +
  geom_sf_text(aes(label = name), size = 3) +
  ggsn::north(s_africa_sa)
```

### Couches supplémentaires **sf**

Nous pouvons superposer plusieurs objets **sf** sur une même carte pour rendre l'information sous forme de couches successives. Ces objets **sf** peuvent contenir des polygones comme nous l'avons vu jusqu'ici, mais ils peuvent aussi contenir d'autres objets comme des points caractérisés par leurs coordonnées latitude et longitude.

A titre d'illustration, nous allons ajouter une couche à la carte de l'Afrique du sud qui localise les capitales des différents pays. Les capitales ainsi que leurs latitudes et longitudes en coordonnées degrés décimaux^[Les coordonnées latitude et longitudes sont d'habitude exprimées en degrés minutes secondes. Par contre, sur ordinateur, la forme degrés décimaux est plus pratique. Les fractions de degrés sont représentés sous forme décimale, ce qui fait que la coordonnées peut être stockée dans un objet `numeric` classique (voir [ici](https://support.google.com/maps/answer/18539?co=GENIE.Platform%3DDesktop&hl=fr)). Des [convertisseurs en ligne](https://www.presqu-ile-de-crozon.com/conversion-des-coordonnees-gps.php) existent pour transformer les coordonnées d'un système à l'autre.] des pays d'Afrique australe sont d'abord encodées dans un tableau classique `s_capitals`.

```{r}
s_capitals <- tibble(
  country = c("Botswana", "Lesotho", "Namibia", "South Africa", "Swaziland"),
  capital = c("Gaborone", "Maseru", "Windhoek",     "Pretoria",   "Lobamba"),
  lat     = c(  -24.7356, -29.3906,   -22.6406,       -25.8209,    -26.5431),
  lon     = c(   25.9113,  27.5015,    17.0782,        28.1909,     31.2012)
)
s_capitals
```

Le tableau `s_capitals` doit ensuite être converti en objet **sf** avec `st_as_sf()` que nous avions déjà utilisé plus haut avant de pouvoir être utilisé pour annoter la carte . Nous devons préciser ici quelles variables représentent les coordonnées des points à l'aide de `coords=` et aussi indiquer quel `crs=` nous souhaitons utiliser.

```{r}
(s_capitals_sa <- st_as_sf(s_capitals, coords = c("lon", "lat"), crs = 4326))
```

Nous constatons que la tableau a été transformé. Nos colonnes `lat` et `lon` ont disparu et une colonne `geometry` a été calculée. Cette colonne contient des objets `sfc_POINT` qui représentent comme leur nom le suggère, des points sur la carte. A ce stade, `geom_sf()` est capable d'utiliser l'information contenue dans l'objet **sf** pour annoter la carte.

```{r}
chart(data = s_africa_sa) +
  geom_sf(fill = "white") +
  geom_sf(data = s_capitals_sa) +
  ggsn::north(s_africa_sa, symbol = 3)
```

Et bien sûr, nous pouvons aussi ajouter le nom de ces capitales sur la carte.

```{r}
chart(data = s_africa_sa) +
  geom_sf(fill = "white") +
  geom_sf(data = s_capitals_sa) +
  geom_sf_label(data = s_capitals_sa, aes(label = capital),
    size = 3, fill = "lightgray", hjust = 1, vjust = 0.5) +
  ggsn::north(s_africa_sa, symbol = 3)
```

Notez que, à chaque addition d'une couche sur le graphique à l'aide de l'opérateur `+`, vous êtes libres de redéfinir les données (`data=`), ou des esthétiques tels que `fill=`. Les données et les esthétiques fournies via la formule dans `chart()` constituent des valeurs par défaut utilisées si elles ne sont pas redéfinies explicitement à chaque appel des fonctions `geom_xxx()`. Donc ici nous utilisons deux fois `geom_sf()` successivement, mais l'effet est très différent car pour la première, nous utilisons les données par défaut définies dans `chart()` (`s_africa_sa`), alors qu'au second appel, nous redéfinissons les données comme étant `s_capitals_sa`. De même, pour `geom_sf_label()` nous sommes obligés de repréciser `data = s_capitals_sa` sinon la fonction utilise à nouveau les données par défaut `s_africa_sa`. Vous imaginez aisément l'immense flexibilité que ce système autorise, en particulier pour la superposition de couches d'information complémentaires via divers objets **sf** sur vos cartes.

### Variables supplémentaires

La coloration de zones d'intérêts est très utilisé en cartographie afin de faire ressortir de l'information. C'est très facile à faire avec R. Il suffit d'avoir ajouté des variables supplémentaires dans notre tableau **sf** et de les utiliser pour le remplissage ou la couleur du trait des polygones. On va utiliser cette méthode pour comparer des zones entre elles. Le graphique ci-dessous compare les densités de population en fonction des pays du continent africain. Il faut donc associer à chaque zone une valeur soit qualitative, soit quantitative. Nous pouvons, par exemple, observer que le pays le plus peuplé est le Nigeria si nous colorons les pays par la variable quantitative `pop_est`. 

```{r}
chart(data = africa_sa, ~ 0 %fill=% pop_est) +
  geom_sf()
```

Dans la version précédente, nous indiquions tous les esthétiques directement dans la formule fournie à `chart()`. Mais nous pouvons également les fournir individuellement à chaque appel de `geom_sf()`. Il faut alors les fournir via `aes()`. Cette méthode est même beaucoup plus compréhensible lorsque nous allons superposer différentes couches sur la carte. Ainsi, le code suivant donne exactement le même résultat.

```{r}
chart(data = africa_sa) +
  geom_sf(aes(fill = pop_est))
```

Nous pouvons naturellement aussi utiliser des variables qualitatives pour colorer nos polygones. Si nous nous intéressons au niveau de développement économique des pays africains, nous utiliserons la variable `economy` à sept modalités. 

```{r}
levels(africa_sa$economy)
```

Sur la carte suivante, nous observons que l'Afrique du Sud, le Zimbabwe, le Kenya, le Nigeria et l'Egypte sont les pays les plus développés du continent africain. Notez que nous avons changé l'échelle de couleur à l'aide de `scale_fill_viridis_d()` ici.

```{r}
chart(data = africa_sa) +
  geom_sf(aes(fill = economy)) +
  scale_fill_viridis_d()
```

## Autres présentations de cartes

De nombreux packages R permettent de réaliser des cartes. Nous avons utilisé jusqu'à présent {ggplot2} pour visualiser nos objets **sf**. Mais d'autres moteurs graphiques peuvent aussi être employés pour générer des cartes statique ou dynamiques et interactives.

### Graphiques de base R

Le package {sf} associé à des instructions en R de base permet de réaliser des cartes. Le R de base à l'avantage d'être très rapide dans son exécution. Le package {cartography} permet d'améliorer ces graphiques comme avec la foncion layoutLayer() pour ajouter un titre, un orientation ou encore une légende. Ce package va donc permettre d'ajouter des couches sur la carte de basepaermet aussi   cartes avec le système graphique de base de R. 

Son interface (les fonctions et leurs arguments à utiliser) est totalement différente de {ggplot2}, de même que le rendu final.

```{r}
library(cartography)
plot(st_geometry(africa_sa),
  col = "grey", border = "grey3", bg = "lightblue1")
plot(st_geometry(s_africa_sa),
  add = TRUE, cex = 1.2, col = "darkseagreen3", pch = 20)
layoutLayer(title = "Afrique", tabtitle = TRUE, north = TRUE, 
  frame = TRUE, posscale = "bottomleft", scale = 1000)
```
### tmap

Le package [{tmap}](https://mtennekes.github.io/tmap/index.html) est un package dédié à la représentation cartographique dont la syntaxe va se rapprocher de celle de ggplot2 (utilisé avec chart()) et la vitesse d'exécution du R de base. Il comprend également une série de fonction de personnalisation de cartes très intéressante. Tout d'abord ce package propose une fonction rapide qtm().

```{r}
library(tmap)
qtm(africa_sa)
```
Il est possible de reproduire ce même graphique en spécifiant couche par couche ce que l'on veut tout comme le propose ggplot2. Nous avons ajouté en plus l'orientation et l'échelle sur la carte. Vous pouvez observer que c'est infiniment plus simple à paramétrer qu'avec le package {ggsn}

```{r}
tm_shape(africa_sa) +
  tm_borders() +
  tm_fill("austral", legend.show = F) + # mise en évidence de l'Afrique Australe
  tm_compass(position = c("right", "top")) + # ajout de l'orientation
  tm_scale_bar(position = c("left", "bottom")) + # ajout de l'échelle
  tm_layout(bg.color = "skyblue") # ajout d'un fond bleu
```
Ce package est très intéressant et nous ne pouvons que vous conseiller à l'explorer.

### Cartes interactives

La librairie JavaScript [leaflet](https://leafletjs.com) est l'une des plus utilisées pour générer des cartes interactives dans un browser web. [OpenStreetMap](https://www.openstreetmap.org) sert de fond de carte ici. Le package R du même nom permet d'utiliser cette librairie dans R et Rstudio. Le package {mapview} offre une surcouche pour faciliter la création de ces cartes interactives, y compris dans des documents R Markdown. C'est très utile pour visualiser ce que contient un objet **sf**.

```{r, eval=FALSE}
SciViews::R
library(sf)
read("World", package = "tmap") %>.%
  st_as_sf(.) %>.%
  filter(., continent == "Africa") %>.%
  mapview::mapview(.)
```

A cause d'un bug dans {leaflet} la carte interactive que l'on obtient ici ne s'affiche pas dans un bookdown. Par contre, si ce code est exécuté dans RStudio (copiez-collez ce code dans la console R dans RStudio), la carte apparaîtra dans l'onglet "Viewer", et vous pourrez utiliser le bouton "Zoom" pour voir cette carte dans une fenêtre agrandie. Il est alors possible de zoomer/dézoomer (boutons + et -), changer de fond de carte (boutons juste en dessous) et visualiser les informations annexes de l'objet **sf** en cliquant sur un pays. Les fonctions de {leaflet} permettent de faire encore plus de choses, voyez [sa documentation](https://rstudio.github.io/leaflet/). C'est un outil fantastique pour explorer de manière interactive des données spatialisées\ !

![](images/06-spatial/mapview.png)

Le package {tmap} propose également de convertir ces cartes en carte interactive avec leaflet.

```{r, eval=FALSE}
tmap_mode("view")
qtm(africa_sa)
```

##### A vous de jouer ! {-}

`r learnr("C06La_map", title = "Réalisation de cartes avec R", toc = "Réalisation de cartes avec R")`

##### Pour en savoir plus {-}

De nombreuses ressources existent sur le Net pour la cartographie avec R. En voici quelques une intéressantes qui vous permettront d'approfondir cette vaste matière.

- [Cartographie avec R](https://rcarto.github.io/carto_avec_r/) est un bookdown en ligne qui présente la cartographie avec R. De nombreuses techniques complémentaires non abordées dans le cours y sont présentées.

- [Initiation à la cartographie avec {sf} & Co. par Sébastien Rochette](https://statnmap.com/fr/2018-07-14-initiation-a-la-cartographie-avec-sf-et-compagnie/) est un article de blog sur la cartographie dans R. Il a rédigé plusieurs article sur le sujet.

- [Visualiser des cartes interactives avec {leaflet}](https://thinkr.fr/cartographie-interactive-comment-visualiser-mes-donnees-spatiales-de-maniere-dynamique-avec-leaflet/) présente quelques types de cartes interactives qui sont réalisable avec {leaflet}.

- Site web du [package sf](https://r-spatial.github.io/sf/index.html). Documentation officielle (en anglais).

- Le [chapitre 6] de "ggplot2: elegant graphics for data analysis" est exclusivement consacré à la réalisation de cartes avec `ggplot()` (en anglais). vous pouvez sans problèmes lui substituer `chart()` et utiliser pour le reste le code présenté ici.

- Introduction rapide à [tmap](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html), en anglais.

- [Article originel](https://www.jstatsoft.org/article/view/v084i06) décrivant {tmap} (en anglais). Vue d'ensemble mais certaines parties ne sont plus d'actualité par rapport à la version actuelle du package.

- Le [chapitre 8](https://geocompr.robinlovelace.net/adv-map.html) de "Geocomputation with R" est entièrement consacré à la réalisation de cartes à l'aide de {tmap} (en anglais).

- Introduction à [{cartography}](https://cran.r-project.org/web/packages/cartography/vignettes/cartography.html), en anglais.

- [Cartographie interactive\ : comment visualiser mes données spatiales de manière dynamique avec {leaflet}](https://thinkr.fr/cartographie-interactive-comment-visualiser-mes-donnees-spatiales-de-maniere-dynamique-avec-leaflet/) est une introduction rapide en français à {leaflet} dans R et Shiny.

## Interpolation spatiale

Parmi les nombreuses techniques statistiques appliquées aux données géoréférencées (autocorrélation spatiale, analyse de motifs de points, modélisation spatiale et spatio-temporelle, classification et segmentation de zones géographiques, ...) nous nous attarderons sur l'une des plus utiles\ : l'**interpolation spatiale**. Son principe consiste à interpoler la variation d'une mesure quantitative dans une zone géographique donnée à partir de mesures éparses. Cette interpolation spatiale permet de construire ensuite des cartes bien plus percutantes.

Il est en effet plutôt rare de pouvoir avoir une couverture dense de mesures sur une grande étendue géographique. Si nous prenons l'exemple de données météorologiques, mis à part l'utilisation d'image satellites, les données sont la plupart du temps obtenue à partir d'un réseau de station météorologiques plus ou moins dense. Dans notre exemple, nous nous intéresserons à la **pluviométrie** exprimée en mm d'eau par an. Un pluviomètre est un appareil simple qui recueille l'eau tombée du ciel sur une surface donnée et qui contient un tube gradué en mm. Il suffit alors de lire la valeur -après un laps de temps donné pour connaître la quantité cumulée d'eau qui est tombée du ciel. 

![Pluviomètre, par [Jean Wilmotte](http://www.jeanwilmotte.it/page/103/), CC-BY-SA.](images/06-spatial/pluviometre.jpg )

### Où pleut-il au Maroc\ ?

En Europe de l'Ouest, le réseau de station météorologiques est assez dense et l'interpolation spatiale ne pose pas de problèmes particuliers pour ces données, sauf peut être localement et à très petite échelle. Par contre, le Maroc est un exemple de pays qui pose problème de ce point de vue pour deux raisons\ :

1. Le réseau de stations météorologiques y est peu dense, surtout dans les régions désertiques du sud du pays.

2. La distribution de la pluviométrie y est très inégale. Elle est forte près de la mer et sur un versant de la chaîne montagneuse de l'Atlas, alors qu'elle est quasi-nulle dans la partie aride du nord ouest du Sahara.

Nous allons donc nous donner comme challenge d'interpoler la pluviométrie sur tout le territoire de ce pays, sur base de seulement une quarantaine de stations d'observation. Ces données sont dans le package {aurelhy} qui n'est malheureusement pas installé par défaut dans la SciViews Box. Nous allons donc commencer par l'installer.

```{r, eval=FALSE}
remotes::install_github("phgrosjean/aurelhy")
```

Nous avons les frontières du pays dans `mbord`, une cartographie détaillée du relief avec un maillage d'un peu moins d'1km * 1km dans `morocco`, les données de pluviométrie dans `mrain` et la distance à la mer dans `mseadist` (plus un marsque indiquant la région à interpoler dans `mmask`). Par contre, tous ces objets sont spécifiques à {aurelhy}. Nous devons donc commencer par les convertir en objets **sf** ou **raster** plus classiques.

### Interpolation avec AURELHY

<details><summary>Cette section est facultative.</summary>

Les météorologues ont depuis toujours dû réaliser des cartes de pluviométrie. Mais la pluie n'est bien évidemment pas mesurée partout, seulement en quelques stations. Les techniques d'interpolation spatiale vues ci-dessus ne fonctionnent pas bien dans ce cas si le relief est très vallonné. En effet, il est bien connu qu'en zone montagneuse, la pluie tombe bien plus d'un côté de la montagne que de l'autre, créant ainsi une frontière nette dans la distribution de la pluviométrie... un phénomène que la plupart des techniques d'interpolation spatiale sont incapables de reproduire correctement. De plus, d'autres variables jouent un rôle important. Par exemple, plus le site est proche de la mer, plus la pluviométrie risque d'augmenter, d'un point de vue statistique.

La méthode [AURELHY](https://www.documentation.ird.fr/hor/fdi:25973) tient compte du relief pour les interpolations de données hydrométéorologiques. Pour le biologiste, une estimation correcte des conditions météorologiques sur son site est souvent indispensable. Mais cette technique peut aussi lui être utile à chaque fois qu'il veut interpoler une variable pour laquelle il peut établir une corrélation avec une ou plusieurs autres variables qui elles sont mieux quantifiées sur le terrain étudié.

Dans R, le package {aurelhy} fait ce type d'interpolation. Il n'est **pas** installé par défaut dans la SciViews Box mais peut l'être via l'instruction suivante\ :



Nous allons reprendre l'interpolation de la pluviométrie sur le territoire marocain qui est l'exemple proposé dans ce package {aurelhy}. Toutes les données nécessaires sont fournies. Il nous faut\ :

- Un modèle terrain (le relief) avec une résolution suffisante (ici  une grille de 924x924m) **et qui s'étend un peu au delà de la zone à interpoler tout autour** afin d'avoir suffisamment d'information dans toutes les fenêtres d'interpolation utilisées.

```{r}
library(aurelhy)
data(morocco)
class(morocco)
attr(morocco, "coords")
```

Nous récupérons aussi la frontière du Maroc dans `mbord` et les données de pluviométrie dans `mrain`. Nous réalisons une carte avec ces données (stations pluviométriques en rouge).

```{r}
data(mbord) # Frontières du Maroc
data(mrain) # Données de pluviométrie
image(morocco)
grid()
lines(mbord, col = "black")
points(mrain, col = "red")
```

La même carte n'est pas réalisable avec {ggplot2}/`chart()` parce que le modèle terrain contient plus de 3,7 millions de points et que c'est beaucoup trop de données pour ce moteur graphique-là. Néanmoins, nous pouvons réaliser une carte en utilisant {tmap} à conditions de convertir nos objets d'abord. Pour le modèle terrain, nous faisons\ :


```{r}
library(raster)
m_coords <- coords(morocco)
mor_ras <- raster(t(unclass(morocco))[ncol(morocco):1, ],
  xmn = m_coords["x1"], xmx = m_coords["x2"],
  ymn = m_coords["y1"], ymx = m_coords["y2"],
  crs = "+proj=longlat +datum=WGS84")
class(mor_ras)
```

<!--
CECI CORRESPOND A UN ESSAI INFRUCTUEUX DE CONVERSION EN **stars**
Je le garde pour mémoire...

L'objet `morocco` est un `geomat` propre à {aurelhy} (voir `?geomat`). C'est un objet très simple constitué d'une matrice représentant l'élévation du terrain en mètres sur une grille carrée avec un attribut `coords` qui contient `size`, la largeur d'une maille de la grille, et `x`et `y`, les latitudes et longitudes du point supérieur gauche de la grille toutes trois exprimées en degrés décimaux selon le système CRS WGS 84. Les objets **sf** ne peuvent contenir que des données vectorielles. Pour ce type de données nous devons utiliser les objects **stars** du package {stars}. Pour la conversion, devons créer une grille curviléaire car les coordonnées sont en latitude et longitude, et ensuite indiquer le type ce CRS qui est utilisé ici\ :

```r
library(stars)
# Dimensions must be named x and y
names(dim(morocco)) <- c("x", "y")
m_coords <- coords(morocco)
m_rows <- dim(morocco)["x"]
m_cols <- dim(morocco)["y"]
m_size <- m_coords["size"]
# Matrices of lat and long for the centers of each grid pixel
m_x <- m_coords["x"] + ((1:m_rows) - 0.5) * m_size
mat_x <- matrix(m_x, nrow = m_rows, ncol = m_cols, byrow = TRUE)
names(dim(mat_x)) <- c("x", "y")
m_y <- m_coords["y"] + ((1:m_cols) - 0.5) * m_size
mat_y <- matrix(m_y, nrow = m_rows, ncol = m_cols, byrow = FALSE)
names(dim(mat_y)) <- c("x", "y")
tm <- st_as_stars(morocco)
# Convert into long & lat grid with WGS84 CRS
tm <- st_as_stars(tm, curvilinear = list(x = mat_x, y = mat_y))
# Add the CRS in use (WGS84 with lat & long positions for the grid)
st_crs(tm) <- "+proj=longlat +ellps=WGS84 +no_defs"
tm
```
-->

<!--
Nous allons maintenant combiner ce modèle terrain avec une couche indiquant les frontières du Maroc.

```r
library(tmap)
library(spData)
library(sf)
world <- st_as_sf(read("world", package = "spData"))
class(world)
mor_bord <- filter(world, name_long == "Morocco")
```

```r
map_mor <- tm_shape(mor_bord) + tm_polygons()
map_mor
```

Carte avec élévations et frontières.

```r
map_mor + tm_shape(mor_ras) + tm_raster(alpha = 0.7)
```

Nous voyons bien que ces frontières ne sont pas assez détaillées. Nous utilisons des données plus précises.
-->

Ce modèle terrain est assez large car il contient `r length(mor_ras)` pixels. C'est beaucoup plus qu'il n'est faut pour notre carte, et celle-ci sera très lente à tracer... de manière inutile (notez que cette résolution est, par ailleurs, indispensable poiur la méthode AURELHY qui est présentée tout à la fin de la section "interpolation spatiale" à la fin de ce module). Nous pouvons réduire la résolution d'un **raster** avec la fonction `aggregate()` d'un facteur 5, ce qui réduira sa taille de 5 * 5 = 25 fois comme ceci\ :

```{r}
res(mor_ras)
length(mor_ras)
# Réduire la résolution d'un facteur 5
mor_ras2 <- aggregate(mor_ras, fact = 5)
res(mor_ras2)
length(mor_ras2)
```

Maintenant, nous n'avons plus que `r length(mor_ras)` pixels à manipuler et à représenter sur la carte. Effectuons une carte avec `chart()` et donc, le moteur graphique {ggplot2}. Il n'est pas facile de combiner des objets **raster** dans un tel graphique. Plusieurs pistes existent, mais si nous voulons continuer à utiliser la fonction `geoml_sf()` pour tous les éléments vectoriels (frontière des pays, rivières, points sur la carte, ...), nous devons convertir notre **raster** en un autre objet **stars** et utiliser `geom_stars(, sf = TRUE)` qui est la seule option pour rester compatible avec **sf**. Cela donnerait quelque chose comme ceci\ :

```{r, eval=FALSE}
library(stars)
chart(data = m_bord) +
  geom_stars(data = st_as_stars(mor_ras2), sf = TRUE) +
  geom_sf()
```

Ce code n'est **pas** évalué et aucun graphique n'est produit car, même avec la résolution réduite de `mor_ras2`, les temps de calcul explosent. Ceci montre les limitations du moteur graphique {ggplot2} qui est très flexible mais le plus lent des différents moteurs graphiques. Nous allons donc passer à un autre système de réalisation de cartes dans R qui reprend la phylosophie de {ggplot2} sans en avoir les inconvénients\ : {tmap}.

Nous devons convertir la frontière du Maroc en objet **sf**.

```{r}
mbord[[1]] <- mbord[[1]][-(1:28), ] # Useless data at the beginning
m_bord_pts <- st_as_sf(bind_rows(mbord, .id = "id"), coords = c("x", "y"))
m_bord_poly <- st_sf(aggregate(m_bord_pts$geometry, list(m_bord_pts$id),
  function(g) st_cast(st_combine(g), "POLYGON")))
st_crs(m_bord_poly) <- "+proj=longlat +datum=WGS84"
m_bord <- st_as_sf(tibble(name = "Morocco", geometry = st_combine(m_bord_poly)))
```

```{r}
library(tmap)
map_m <- tm_shape(m_bord) + tm_polygons()
map_m
```

Nous devons également convertir les données ponctuelles de pluviométrie en objet **sf**.

```{r}
m_rain <- st_as_sf(mrain, coords = c("x", "y"))
st_crs(m_rain) <- "+proj=longlat +datum=WGS84"
m_rain
```

Et enfin, nous pouvons réaliser une représentation de la même carte avec {tmap}.

```{r}
map_m2 <- map_m + tm_shape(mor_ras) +
  tm_raster(n = 5, alpha = 0.7, title = "Altitude [m]") +
  tm_layout(legend.position = c("left", "top")) +
  tm_shape(m_rain) + tm_dots(col = "red", size = 0.05)
map_m2
```

Nous utilisons aussi un masque qui indique la zone à interpoler (`mmask`) et des données de distance à la mer dans `mseadist`.

```{r}
data(mseadist)
data(mmask)
# S'assurer que toutes les stations sont reprises dans le masque
mmask2 <- add.points(mmask, mrain)
```

A présent, nous interpolons les données de pluviométrie à l'aide de la méthode AURELHY. Les nombreux paramètres de `aurelhy()` sont décrits dans l'aide de la fonction. 

```{r}
m_aurelhy <- aurelhy(morocco, mmask2, auremask(), x0 = 30, y0 = 54, step = 12,
  scale = FALSE, nbr.pc = 10, vgmodel = gstat::vgm(100, "Gau", 1, 1),
  add.vars = mseadist, var.name = "seadist")
```

Cet objet `m_aurelhy` peut ensuite être utilisé pour prédire la pluviométrie (que nous passons temporairement en échelle logarithmique.)

```{r}
mrain$log_rain <- log10(mrain$rain)
pmrain <- predict(m_aurelhy, mrain, "log_rain")
summary(pmrain) 
```

Nous voyons que quelques variables de ce modèle sont très significatives et d'autres le sont moins. Nous pourrions raffiner le modèle et le simplifier (nous vous laissons cela comme exercice). Une fois que nous sommes satisfait du résultat, nous transformons la variable prédite en objet **geomat**, et ensuite en objet **raster** pour le cartographier.

```{r}
geomrain <- as.geomat(pmrain)
geomrain <- 10^geomrain # Revenir de l'échelle logarithmique
```

Comme il se peut que l'interpolation ait donné des valeurs très élevées ou très, très basses en quelques points, nous allons niveler un peu tout cela vers une plage de valeurs effectivement observée.

```{r}
range(geomrain, na.rm = TRUE)
range(mrain$rain)
```

Nous atteignons près de 3500mm/an de pluie en certains endroits, ce qui est énorme. Combien de pixels sont concernés\ ?

```{r}
sum(geomrain > 1000, na.rm = TRUE)
```

Seulement quelques dizaines. Ceci est probablement lié au manque de stations pluviométriques en altitude. Nous limitons les valeurs à 1000mm/an maximum, et ensuite, nous transformons en objet **raster**

```{r}
geomrain[geomrain > 1000] <- 1000
r_coords <- coords(geomrain)
rain_ras <- raster(t(unclass(geomrain))[ncol(geomrain):1, ],
  xmn = r_coords["x1"], xmx = r_coords["x2"],
  ymn = r_coords["y1"], ymx = r_coords["y2"],
  crs = "+proj=longlat +datum=WGS84")
class(rain_ras)
```

Enfin, nous réalisons une carte de la pluviométrie que nous plaçons côte à côte avec la carte du releif pour comparaison.

```{r}
map_rain <- map_m + tm_shape(rain_ras) +
  tm_raster(n = 10, alpha = 0.7, palette = "YlGnBu",
    title = "Pluie [mm/an]") +
  tm_layout(legend.position = c("left", "top")) +
  tm_shape(m_rain) + tm_dots(col = "red", size = 0.05)
# Deux cartes côte à côte
tmap_arrange(map_m2, map_rain)
```

Nous voyons bien, sur la carte de droite, que le relief montagneux de l'Atlas marocain à influencé l'interpolation de la pluviométrie qui est la plus abondante sur les versants orientés vers la mer. Ceci est conforme avec ce qui s'observe sur le terrain.

</details>

##### Pour en savoir plus {-}

- [Intro to GIS and Spatial Analysis](https://mgimond.github.io/Spatial/index.html) est un ouvrage complet qui introduit toute la matière de manière claire, mais qui montre aussi comment l'implémenter dans R (en anglais).

- [Geocomputation with R](https://geocompr.robinlovelace.net/adv-map.html) présente certains aspects complémentaires au précédent ouvrage (en anglais). Il montre, par exemple, comment combiner les capacités géstatistique et d'apprentissage machine dans R pour étudier des modèles spatialisés potentiellement très puissants. Des applications pratiques dans différentes disciplines (dont l'écologie) mettent tout cela en musique.

- [Geospatial Health Data: modeling and visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/) insiste particulièrement sur les cartes interactives et les applications Shiny (dashboard) pour présenter des données et modèles géospatialisés de manière vivante et interactive (en anglais).


## Récapitulatif des exercices

Dans ce module 6, vous aviez à réaliser les exercices suivants\ :

`r show_ex_toc()`

