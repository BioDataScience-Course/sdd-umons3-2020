# (PART) SDD IV : pratique {-}

# Données particulières {#data}

```{r setup, results='hide', warning=FALSE, include=FALSE}
SciViews::R
```

## Dates

<!----- G.E.
Tout ce dont on veut parler dans ce module

- date, POSIXlt (POSIXct), lubridate, difftime

- conversion des caractères en date

- anytime

- nanotime

- benchmark
--->

La gestion du temps et les variables de temps peuvent sembler simple d'apparence. Nous savons facilement déterminer la date et l'heure qu'il est en regardant une montre et un calendrier. Répondez à la question suivante :

Est ce que le temps dure exactement 365 jours ? 

Vous savez que c'est une approximation et que c'est un système complexe que nous allons tenter de simplifier ci-dessous. 

Si on tient compte du calendrier grégorien, des fuseaux horaires, du temps universel coordonné, de l'heure d'été, .... On s'aperçoit que le temps est complexe. 

Le calendrier grégorien et le calendrier le plus utilisé actuellement dans le monde. Ce calendrier définit qu'une année comprend 4 trimestres, 12 mois. Les mois varient entre 28 et 31 jours. Une semaine comprend 7 jours. Une année comprend 365 jours à l'exception des années bissextiles.

Si vous n'avez pas mal de tête, on continue. 

Les fuseaux horaires ont eu pour objectif de définir une heure commune pour un espace géographique déterminé. C'est l'utilisation de chemin de fer qui a rendu la mise en place d'une heure commune indispensable. 

En pratique, une échelle de temps est utilisée comme référence par la majorité des pays du globe. Il s'agit du temps universel coordonné (UTC, *coordinated universal time*). Le terme GMT était utilisé précédemment. Il signifiait *Greenwich Mean time*.  A ce temps de référence, on va ajouter ou soustraire un nombre entier (avec des exceptions comme dans tout système avec l'ajout ou la soustraction d'un nombre entier plus 30 ou 45 minutes.)

UTC est un compromis entre le temps atomique international et temps universel. Il faut savoir que le temps universel coordonné est synchronisé avec la rotation de la Terre qui n'est pas fixe. Le service international de la rotation terrestre et des systèmes de référence décide de l'ajout de seconde, une seconde intercalaire (*leap second*) à UTC comme le premier janvier 2009. 

![Les Fuseaux horaires usuels](images/07-donnees/world_time_zones_map.png)

Après avoir lu ces quelques notions, pensez-vous toujours que le temps est simple ? 

Il nous reste plus qu'à voir comment le temps est géré dans R.

On retrouve les principaux objets suivant dans R pour gérer les temps : `Date`, `POSIXct`, `POSIXlt`, `difftime`. Le package lubridate propose en plus `Period`.

L'objet `Date` va s'intéresser au objet de temps qui référence le jour, le mois et l'année. Le jour 0 d'un objet date est le 1970-01-01. Il s'agit de l'heure Unix (mais nous ne détaillerons pas cette notion).


```{r, warning=FALSE, message=FALSE}
library(lubridate)
(date <- as_date(now()))
class(date)
```

L'objet `POSIXt` est un objet plus précis qui tient compte de la date et de l'heure. On retrouve deux variantes des objet POSIXT qui sont POSIXct et le POSIXlt. Le POSIXCT enregistre le temps depuis l'origine qui est l'heure Unix alors que le POSIXlt utilise des paramètres attributs spécifiques.

```{r}
(datetime <- now())
class(datetime)
```
Enfin les objets `difftime` sont des objets spécifique aux différence entre deux dates.

```{r}
(diff <- today() - ymd("1979-10-14"))
diff1 <- difftime(today(), ymd("1979-10-14")) # seconde manière de calculer une différence entre deux dates.
diff == diff1 # on peut vérifier que diff et diff1 sont identiques.
class(diff)
```

### Conversion d'une chaine de caractère en date

En pratique vous serez souvent amené à convertir des chaînes de caractères en variable de temps. Pour ce faire, le package `lubridate` comprend des fonctions très utile pour convertir des chaînes de caractères en date. 

Regardez par vous même pour en déduire la logique simple ci-dessous :

- Les dates

```{r}
ymd("2015-Jan-25")
dmy("25 janvier 2015")
dmy("25/01/2015")
mdy("01/25/15")
```

- Les heures

```{r}
hm("01:10 am")
hms("20/10:01")
hms("20:10:01")
```

- Les dates et heures

```{r}
ymd_hm("2010-10-01T2010")
ymd_hms("2015-Jan-25 12:25:35")
```


Par défaut, ce package utilise le temps universel coordonné. Il est cependant possible de définir le fuseau horaire avec l'argument tz.

```{r}
ymd_hms(now(), tz = "Europe/Amsterdam")
```

Ces fonctions sont capables de gérer des formats de dates différentes en même temps. Essayez cependant d'éviter ce genre d'erreurs d'encodage.

```{r}
ymd_hms(c("2015-Jan-25 12:25:35", "2015-01-15T122535", "2015/01/25 12:25:35"), tz = "Europe/Amsterdam")
```

<details>
<summary>Plus de détails...</summary>
Pour avoir plus de flexibilité, il est possible d'utiliser la fonction `parse_date_time()` qui va permettre de spécifier des formats spécifique. 

- Année
    + %Y : 4 chiffres
    + %y : 2 chiffres
- Mois
    + %m : 2 chiffres
    + %b : nom abrégé
    + %B : nom complet
- Jour 
    + %d : 2 chiffres
- Heure
    + %H : 0-23h
    + %i combiné avec %p : 0-12 suivi am/pm
    + %M : minutes
    + %S : secondes entières
    + %OS : secondes réelles
    + %Z : fuseau horaire
    + %z : décalage par rapport à UTC : +0100 (plus 1h)
- Valeurs à ignorer
    + %. : ignore des caractère non numérique
    + %* : ignore une suite de caractères non numériques
</details>

Vous serez un jour confronté à un tableau de données du type suivante avec plusieurs colonnes qui renseigne sur le temps de la prise de mesure. 

```{r}
(df <- tibble(
  annee = c(2010, 2011, 2012, 2013),
  mois = c(01, 01, 01, 01),
  jour = c(01, 01, 01, 01)
))
```

Rassurez vous, il n'est pas nécessaire de combiner les 3 colonnes puis de les transformer en variable temporelle. La fonction `make_date()` permet de créer un variable qui combine nos trois colonnes. Il existe la même variante pour `make_datetime()`.

```{r}
df %>.%
  mutate(., date = make_date(annee, mois, jour))
```

### Temps biologique

Lorsque vous étudiez un phénomène biologique, il faut vous poser la question de la temporalité de votre expérience. 

- Est ce que votre expérience dure quelques heures ? quelques jours ? quelques mois ? 


<!----- G.E.
TODO : DIVISION des années avec la logique de pastecs

Imaginons que vous étudiez la croissance d'organisme sur plusieurs années.  Certainement exliqué dans les séries temporelles donc renvoyer vers ce module là

TODO : simplification des dates (un organisme biologique s'en fiche d'une année bissextiles) que nous soyons le dimanche 5 janvier. On s'intéresse au nombre de jour ou d'heure depuis le début de la manip.
----->

##### Pour en savoir plus {-} 

- [Travailler avec des dates dans R](https://dhaine.github.io/clinicR/src/20150506-date.html)

- [Chapter 16 Dates and times in R For Data Science](https://r4ds.had.co.nz/dates-and-times.html) : Le chapitre 16 du livre R for Data Science traite des variables temporelles.

## Données textuelles

### Encodages

Nous avons tous déjà été confronté à ce genre de caractères `Ã©` ou `�`. Il s'agit d'un problème d'encodage. Vous avez certainement entendu les termes suivants ASCII, UTF-8, LATIN-1,... 

La problématique est de convertir une chaine de caractères en bits qui sera interprété par l'ordinateur. Il faut donc attribuer à chaque caractère un code unique. Cette série de code vont permettre la traduction des caractères. Les fameux termes cité précédemment sont les encodages qui permette cette traduction. 

Historiquement, le code américain normalisé pour l’échange d'informations (*ASCII*, American Standard Code for Information Interchange) a été l'un des premiers système d'encodage proposé. Cette proposition était simple et adpatée uniquement à l'anglais. Il ne prenait par exemple pas en compte les nombreux accents de la langue française. Il s'en suit du développement de plusieurs systèmes d'encodages avec des adaptions spécifique au très nombreuses langues mondiales comme **ISO 8859** pour les langues latines (*ISO 8859-1*, *latin_1*) ou encore ISO-2020 pour les langues asiatiques.

Afin de réduire les problèmes d'encodage, l'idée de proposée un jeu universel de caractères est de développé, *ISO 10646*. Le consortium Unicode propose une surcouche à cette norme appelé *unicode*. Vous vous en doutez que plus il va y avoir des caractères plus le système d'encodage sera lourd et va utiliser de la capacité 

L'*UTF-32*, puis *UTF-16* et enfin l'*UTF-8* est proposé afin d'économiser de la mémoire de l'ordinateur. L'*UTF-8* est compatible avec l'ASCII ce qui permet de réutiliser d'anciens programmes. 

Nous vous conseillons donc de toujours employer le format **UTF-8**. 

##### Pour en savoir plus {-} 

<!--- G.E.
Liste provisavoire des liens utiles utilisé pour rédiger la section précédente.
--->

-  [Encodages de caractères pour débutants](https://www.w3.org/International/questions/qa-what-is-encoding.fr)

- [Tutoriel : Comprendre les encodages](http://sdz.tdct.org/sdz/comprendre-les-encodages.html)

### Traitements de texte

On utilise des chaînes de caractères dans de nombreux contexte : 

- nom de fichier
- analyse de texte
- analyse de date 
- coordonnées
- ADN/ARN
- facteur-niveaux
- ...

Afin de manipuler des chaînes de caractères, de nombreuses fonctions sont disponibles. Nous utiliserons principalement les fonctions du package `stringr`.

```{r}
library(stringr)
```

Partons de la chaîne de caractères suivante :

```{r}
string <- "Je suis étudiant en science des données biologiques"
```

Répondez à la question suivante : Quel est la longueur de cette chaîne de caractère ?

```{r}
length(string)
str_length(string) # ou bien la version en R de base nchar(string)
```

Vous attendiez vous à ces deux résultats ? La fonction length() renvoie la longueur de l'objet. La fonction str_length() (ou bien nchar()) renvoie le dénombrement des caractères au sein d'une chaine de caractère. 
Reposons nous la même question cette fois ci avec un vecteur de chaînes de caractères.

```{r}
strings <- c("Je suis étudiant en science des données biologiques", "Je suis le cours de sdd4", "J'aime appliquer les concepts de la science des données lors d'expérience en biologie")

length(strings)
str_length(strings) # ou bien la version en R de base nchar(strings)
```

Cet exemple montre une fois de plus l'importance de lire l'aide d'une fonction et de tenter de faire des tests très simple pour s'assurer de bien comprendre la fonction et ces arguments. Les noms des fonctions sont très importants et peuvent parfois vous porter à confusion.  

Au sein d'un laboratoire, vous êtes engagé pour développer une nouvelle méthode de dosage de nitrate. Imaginons que vous avez attribué un identifiant à 6 expériences que vous avez réalisées en routine lors de dosages des nitrates. 

Nous pouvons observer que le nom de fichier suit la logique suivante

> nom de l'expérience + numéro de l'expérience + méthode employée + date

```{r}
id <- c(
  "Nitrate.1100.Version1.2019-10-21", "Nitrate.1101.Version2.2019-10-21",
  "Nitrate.1109.Version1.2019-10-24","Nitrate.1110.Version2.2019-10-24",
  "Nitrate.1114.Version1.2019-10-26","Nitrate.1115.Version2.2019-10-26")
id
```
Votre chef vous demande de lui présenter les documents en lien avec les dosages de nitrate version 2 que vous avez développé.  Il est possible de le faire avec une simple instruction.

```{r}
str_subset(id, "Version2")
```
A la suite de votre réunion, votre chef vous demande de modifier le nom de vos dossiers car il ne respecte pas les conventions de notation en vigueur dans le laboratoire. Votre supérieur vous demande donc de remplacer toutes les majuscules par des minuscules. Avec la bonne fonction dans R, cela est réalisable en une seule instruction simple.

```{r}
str_to_lower(id)
```
Il vous demande également de remplacer **tous** les `.` par des `_`. 

```{r}
str_replace_all(id, ".","_")
```
Vous attendiez vous à ce résultat ? Nous sommes sûrs que non. Avez-vous lu l'aide de la fonction ? L'argument `pattern` utilise une expression régulière et pas une simple chaîne de caractères. Les expressions régulières sont des outils puissants lorsqu'ils sont judicieusement employés. Afin de remplacer les `.` par des `_`, il aurait fallu utiliser :

```{r}
id %>.%
  stringr::str_to_lower(.) %>.%
  stringr::str_replace_all(., "\\.","_") -> id_new
id_new
```
En effet, le `.` a une signification particulière lors de l'utilisation de l'expression régulière que nous allons voir dans la section suivante.

##### Pour en savoir plus {-}

- [Introduction to stringr](https://stringr.tidyverse.org/articles/stringr.html). Ce poste propose une introduction en anglais au package `stringr`

- [From base R](https://stringr.tidyverse.org/articles/from-base.html). Ce poste propose en anglais une comparaison entre les fonctions de R de base et les fonctions du package de `stringr`

### Expression régulière

La syntaxe de base des expressions régulières est proposée ci-dessous

- qui débute par chien : "^nitrate"
- qui termine par chien : "nitrate$"
- qui cherche nitrate et le mot nitrite  : "(nitrate|nitrite)"
- qui se répète plusieurs fois : 
      + ? de 0 à 1 fois
      + + 1 ou plusieurs
      + * 0 ou plusieurs
      + -{2,6}répétitions comprise entre 2 et 6 fois
- ., n'importe quels caractères
- .*, n'importe quels caractère après
- [0-9] un chiffre de 0 à 9 on peut également utiliser \\ d (double backslah du à R)
- [a-z]
– [A-Z]
- [^0-9] je veux tous les caractères sauf un chiffre

Si je veux rechercher un point je dois écrire \\.

##### A vous de jouer {-}

```{block2, type='bdd'}
Il n'est possible de véritablement comprendre les expressions régulières qu'en réalisant des exercices. Nous vous proposons donc de réaliser les exercices proposés sur le site [RegexOne](https://regexone.com/). Les exercices sont nombreux et interactifs. 
````

Dans R, Le package `regexplain` propose des `Addins` pour vous aider à utiliser les expressions régulières dans R. Ces expressions régulières sont souvent utilisables dans toutes les fonctions `stringr` que nous avons vu précédemment.


##### Pour en savoir plus {-}

- [Regexone](https://regexone.com/) : Tutoriel interactif en anglais pour apprendre a utiliser les expressions régulières.

- [Tutoriel pour maîtriser les expressions régulières](https://www.lucaswillems.com/fr/articles/25/tutoriel-pour-maitriser-les-expressions-regulieres) : Article de blog en français pour apprendre les bases des expressions régulières.

### Variables facteurs

Partons d'une expérience sur la croissance de scléractiniaires. Nous avons donc un vecteur ci-dessous qui correspond à au nom abrégé des espèces étudiées. Le nombre d'espèces est fini. Chaque est espèce correspond donc à un groupe d'individus d'une même espèce. 

```{r}
species <- c("s.hystrix", "p.damicornis", "a.millepora", "p.damicornis", "a.millepora", "s.hystrix", "s.hystrix", "p.damicornis", "a.millepora", "p.damicornis", "a.millepora", "s.hystrix", "a.millepora")

species
# format de la variables :  species
class(species)
```

Afin de gérer ce type de variable, on utilise les variables facteurs dans R.


La gestion correcte des variables facteurs dans R est particulière et peut mener à des erreurs. Nous vous conseillons la lecture de cet article sur le sujet [Wrangling categorical data in R](https://peerj.com/preprints/3163/).


En R de base, la fonction qui permet de transformer une variable en une variable facteur est factor(). On retrouve des variantes à ces fonctions comme as.factor(), as.ordered() (ou encore as_factor() du package forcats). Nous vous conseillons d'utiliser factor() car cette fonction permet une meilleure gestion des variables facteurs. Il est important de comprendre la logique de gestion des facteurs dans R. Afin de gagner de la mémoire, R va attribuer à chaque niveau d'une variable facteur un nombre entier. Les niveaux vont être attribués par ordre alphabétique.

```{r}
species_fac <- factor(species)
species_fac

# Niveau de la variable species_fac
levels(species_fac)
# entiers associé à ces niveaux
as.integer(species_fac)
```
Pour une variable d'une taille conséquente, on s'aperçoit qu'une variable facteur utilise moins d'espace en mémoire qu'une variable caractère.

```{r}
species_length <- sample(species, size = 10000, replace = TRUE)

object.size(species_length)
object.size(as.factor(species_length))
```

Dans notre exemple, l'espace nécessaire est moitié moins important. Rappelez-vous que la première version de R date de 1993. La préoccupation de la mémoire était très importante à l'époque. De nombreuses fonctions plus anciennes vont utilisées de préférence des variables facteurs. Par exemple, la fonction read.csv() va par défaut tenter de transformer une variable caractère en une variable facteur alors que la fonction read_csv() du package `readr` va laisser la variable en caractère. Nous vous conseillons d'importer vos données en caractère et des les transformer en variable facteur si cela est nécessaire. 

Afin de permettre de travailler plus facilement avec une variable facteur, de nombreuses fonctions sont à votre disposition comme la fonction recode() du package `dplyr` ou encore des fonctions disponibles dans le package `forcats`.

```{r}
recode(species_fac,
       "a.millepora" = "acropora.millepora",
       "p.damicornis" = "pocillopora_damicornis",
       "s.hystrix" = "seriatopora_hystrix")
```

```{block2, type='warning'}
Les variables facteurs sont utiles mais il faut toujours prendre le temps de bien comprendre chaque niveau de la variable. Soyons encore plus vigilant si les données sont amenées à évoluer au cours du temps. 
```

##### Pour en savoir plus {-}

- [Chapter 15 Factors in R For Data Science](https://r4ds.had.co.nz/factors.html) : Le chapitre 15 du livre R for Data Science traite des variables facteurs.

- [Wrangling categorical data in R](https://peerj.com/preprints/3163/) : un article en anglais sur la différence d'approche entre la gestion des variables facteurs en R de base et avec tidyverse.

- [Introduction to forcats](https://forcats.tidyverse.org/articles/forcats.html) : une introduction en anglais au package forcats.

## Données circulaires


